//                        delegate.hh 
//    Efficient delegates in C++ that generate only two lines of asm code!
//  Documentation is found at http://www.codeproject.com/cpp/FastDelegate.asp
//
//                        - Don Clugston, Mar 2004.
//        Major contributions were made by Jody Hagins.
// History:
// 24-Apr-04 1.0  * Submitted to CodeProject.
// 28-Apr-04 1.1  * Prevent most unsafe uses of evil static function hack.
//                  * Improved syntax for horrible_cast (thanks Paul Bludov).
//                  * Tested on Metrowerks MWCC and Intel ICL (IA32)
//                  * Compiled, but not run, on Comeau C++ and Intel Itanium ICL.
// 27-Jun-04 1.2  * Now works on Borland C++ Builder 5.5
//                  * Now works on /clr "managed C++" code on VC7, VC7.1
//                  * Comeau C++ now compiles without warnings.
//                  * Prevent the virtual inheritance case from being used on 
//                      VC6 and earlier, which generate incorrect code.
//                  * Improved warning and error messages. Non-standard hacks
//                     now have compile-time checks to make them safer.
//                  * implicit_cast used instead of static_cast in many cases.
//                  * If calling a const member function, a const class pointer can be used.
//                  * MakeDelegate() global helper function added to simplify pass-by-value.
//                  * Added fastdelegate.clear()
// 16-Jul-04 1.2.1* Workaround for gcc bug (const member function pointers in templates)
// 30-Oct-04 1.3  * Support for (non-void) return values.
//                  * No more workarounds in client code!
//                     MSVC and Intel now use a clever hack invented by John Dlugosz:
//                     - The FASTDELEGATEDECLARE workaround is no longer necessary.
//                     - No more warning messages for VC6
//                  * Less use of macros. Error messages should be more comprehensible.
//                  * Added include guards
//                  * Added FastDelegate::empty() to test if invocation is safe (Thanks Neville Franks).
//                  * Now tested on VS 2005 Express Beta, PGI C++
// 24-Dec-04 1.4  * Added DelegateMemento, to allow collections of disparate delegates.
//                * <,>,<=,>= comparison operators to allow storage in ordered containers.
//                  * Substantial reduction of code size, especially the 'Closure' class.
//                  * Standardised all the compiler-specific workarounds.
//                * MFP conversion now works for CodePlay (but not yet supported in the full code).
//                * Now compiles without warnings on _any_ supported compiler, including BCC 5.5.1
//                  * New syntax: FastDelegate< int (char *, double) >. 
// 14-Feb-05 1.4.1* Now treats =0 as equivalent to .clear(), ==0 as equivalent to .empty(). (Thanks elfric).
//                  * Now tested on Intel ICL for AMD64, VS2005 Beta for AMD64 and Itanium.
// 30-Mar-05 1.5  * Safebool idiom: "if (dg)" is now equivalent to "if (!dg.empty())"
//                  * Fully supported by CodePlay VectorC
//                * Bugfix for Metrowerks: empty() was buggy because a valid MFP can be 0 on MWCC!
//                * More optimal assignment,== and != operators for static function pointers.

#ifndef DELEGATE_DELEGATE_HH_
#define DELEGATE_DELEGATE_HH_

#include <atomic>
#include <cassert>
#include <memory>
#include <memory.h> // to allow <,> comparisons
#include <delegate/bind.hh>

////////////////////////////////////////////////////////////////////////////////
//                        Compiler identification for workarounds
//
////////////////////////////////////////////////////////////////////////////////

// Compiler identification. It's not easy to identify Visual C++ because
// many vendors fraudulently define Microsoft's identifiers.
#if defined(_MSC_VER) && !defined(__MWERKS__) && !defined(__VECTOR_C) && !defined(__ICL) && !defined(__BORLANDC__)
#define FASTDLGT_ISMSVC
#endif

// Does the compiler uses Microsoft's member function pointer structure?
// If so, it needs special treatment.
// Metrowerks CodeWarrior, Intel, and CodePlay fraudulently define Microsoft's 
// identifier, _MSC_VER. We need to filter Metrowerks out.
#if defined(_MSC_VER) && !defined(__MWERKS__)
#define FASTDLGT_MICROSOFT_MFP

#if !defined(__VECTOR_C)
// CodePlay doesn't have the __single/multi/virtual_inheritance keywords
#define FASTDLGT_HASINHERITANCE_KEYWORDS
#endif
#endif

////////////////////////////////////////////////////////////////////////////////
//                        General tricks used in this code
//
// (a) Error messages are generated by typdefing an array of negative size to
//     generate compile-time errors.
// (b) Warning messages on MSVC are generated by declaring unused variables, and
//        enabling the "variable XXX is never used" warning.
// (c) Unions are used in a few compiler-specific cases to perform illegal casts.
// (d) For Microsoft and Intel, when adjusting the 'this' pointer, it's cast to
//     (char *) first to ensure that the correct number of *bytes* are added.
//
////////////////////////////////////////////////////////////////////////////////
//                        Helper templates
//
////////////////////////////////////////////////////////////////////////////////


namespace Hypergrace {
namespace Delegate {

namespace Details {    // we'll hide the implementation Detailss in a nested namespace.

//        implicit_cast< >
// I believe this was originally going to be in the C++ standard but
// was left out by accident. It's even milder than static_cast.
// I use it instead of static_cast<> to emphasize that I'm not doing
// anything nasty.
// Usage is identical to static_cast<>
template <class OutputClass, class InputClass>
inline OutputClass implicit_cast(InputClass input)
{
    return input;
}

//        horrible_cast< >
// This is truly evil. It completely subverts C++'s type system, allowing you 
// to cast from any class to any other class. Technically, using a union 
// to perform the cast is undefined behaviour (even in C). But we can see if
// it is OK by checking that the union is the same size as each of its members.
// horrible_cast<> should only be used for compiler-specific workarounds. 
// Usage is identical to reinterpret_cast<>.

// This union is declared outside the horrible_cast because BCC 5.5.1
// can't inline a function with a nested class, and gives a warning.
template <class OutputClass, class InputClass>
union horrible_union
{
    OutputClass out;
    InputClass in;
};

template <class OutputClass, class InputClass>
inline OutputClass horrible_cast(const InputClass input)
{
    horrible_union<OutputClass, InputClass> u;
    // Cause a compile-time error if in, out and u are not the same size.
    // If the compile fails here, it means the compiler has peculiar
    // unions which would prevent the cast from working.
    typedef int ERROR_CantUseHorrible_cast[sizeof(InputClass)==sizeof(u) 
        && sizeof(InputClass)==sizeof(OutputClass) ? 1 : -1];
    u.in = input;
    return u.out;
}

////////////////////////////////////////////////////////////////////////////////
//                        Fast Delegates, part 1:
//
//        Conversion of member function pointer to a standard form
//
////////////////////////////////////////////////////////////////////////////////

// GenericClass is a fake class, ONLY used to provide a type.
// It is vitally important that it is never defined, so that the compiler doesn't
// think it can optimize the invocation. For example, Borland generates simpler
// code if it knows the class only uses single inheritance.

// Compilers using Microsoft's structure need to be treated as a special case.
#ifdef  FASTDLGT_MICROSOFT_MFP

#ifdef FASTDLGT_HASINHERITANCE_KEYWORDS
    // For Microsoft and Intel, we want to ensure that it's the most efficient type of MFP 
    // (4 bytes), even when the /vmg option is used. Declaring an empty class 
    // would give 16 byte pointers in this case....
    class __single_inheritance GenericClass;
#endif
    // ...but for Codeplay, an empty class *always* gives 4 byte pointers.
    // If compiled with the /clr option ("managed C++"), the JIT compiler thinks
    // it needs to load GenericClass before it can call any of its functions,
    // (compiles OK but crashes at runtime!), so we need to declare an 
    // empty class to make it happy.
    // Codeplay and VC4 can't cope with the unknown_inheritance case either.
    class GenericClass {};
#else
    class GenericClass;
#endif

// The size of a single inheritance member function pointer.
const int SINGLE_MEMFUNCPTR_SIZE = sizeof(void (GenericClass::*)());

//                        SimplifyMemFunc< >::convert()
//
//  A template function that converts an arbitrary member function pointer into the 
//  simplest possible form of member function pointer, using a supplied 'this' pointer.
//  According to the standard, this can be done legally with reinterpret_cast<>.
//  For (non-standard) compilers which use member function pointers which vary in size 
//  depending on the class, we need to use    knowledge of the internal structure of a 
//  member function pointer, as used by the compiler. Template specialization is used
//  to distinguish between the sizes. Because some compilers don't support partial 
//  template specialisation, I use full specialisation of a wrapper struct.

// general case -- don't know how to convert it. Force a compile failure
template <int N>
struct SimplifyMemFunc
{
    template <class X, class XFuncType, class GenericMemFuncType>
    inline static GenericClass *convert(X *pthis, XFuncType function_to_bind, 
        GenericMemFuncType &bound_func)
    { 
        // Unsupported member function type -- force a compile failure.
        // (it's illegal to have a array with negative size).
        typedef char ERROR_Unsupported_member_function_pointer_on_this_compiler[N-100];
        return 0; 
    }
};

// For compilers where all member func ptrs are the same size, everything goes here.
// For non-standard compilers, only single_inheritance classes go here.
template <>
struct SimplifyMemFunc<SINGLE_MEMFUNCPTR_SIZE>
{    
    template <class X, class XFuncType, class GenericMemFuncType>
    inline static GenericClass *convert(X *pthis, XFuncType function_to_bind, 
            GenericMemFuncType &bound_func)
    {
        bound_func = reinterpret_cast<GenericMemFuncType>(function_to_bind);
        return reinterpret_cast<GenericClass *>(pthis);
    }
};

////////////////////////////////////////////////////////////////////////////////
//                        Fast Delegates, part 1b:
//
//                    Workarounds for Microsoft and Intel
//
////////////////////////////////////////////////////////////////////////////////


// Compilers with member function pointers which violate the standard (MSVC, Intel, Codeplay),
// need to be treated as a special case.
#ifdef FASTDLGT_MICROSOFT_MFP

// We use unions to perform horrible_casts. I would like to use #pragma pack(push, 1)
// at the start of each function for extra safety, but VC6 seems to ICE
// intermittently if you do this inside a template.

// __multiple_inheritance classes go here
// Nasty hack for Microsoft and Intel (IA32 and Itanium)
template<>
struct SimplifyMemFunc<SINGLE_MEMFUNCPTR_SIZE + sizeof(int)>
{
    template <class X, class XFuncType, class GenericMemFuncType>
    inline static GenericClass *convert(X *pthis, XFuncType function_to_bind, 
        GenericMemFuncType &bound_func)
    { 
        // We need to use a horrible_cast to do this conversion.
        // In MSVC, a multiple inheritance member pointer is internally defined as:
        union
        {
            XFuncType func;
            struct
            {
                GenericMemFuncType funcaddress; // points to the actual member function
                int delta;                      // #BYTES to be added to the 'this' pointer
            } s;
        } u;
        // Check that the horrible_cast will work
        typedef int ERROR_CantUsehorrible_cast[sizeof(function_to_bind)==sizeof(u.s)? 1 : -1];
        u.func = function_to_bind;
        bound_func = u.s.funcaddress;
        return reinterpret_cast<GenericClass *>(reinterpret_cast<char *>(pthis) + u.s.delta); 
    }
};

// virtual inheritance is a real nuisance. It's inefficient and complicated.
// On MSVC and Intel, there isn't enough information in the pointer itself to
// enable conversion to a closure pointer. Earlier versions of this code didn't
// work for all cases, and generated a compile-time error instead.
// But a very clever hack invented by John M. Dlugosz solves this problem.
// My code is somewhat different to his: I have no asm code, and I make no 
// assumptions about the calling convention that is used.

// In VC++ and ICL, a virtual_inheritance member pointer 
// is internally defined as:
struct MicrosoftVirtualMFP
{
    void (GenericClass::*codeptr)(); // points to the actual member function
    int delta;                       // #bytes to be added to the 'this' pointer
    int vtable_index;                // or 0 if no virtual inheritance
};
// The CRUCIAL feature of Microsoft/Intel MFPs which we exploit is that the
// m_codeptr member is *always* called, regardless of the values of the other
// members. (This is *not* true for other compilers, eg GCC, which obtain the
// function address from the vtable if a virtual function is being called).
// Dlugosz's trick is to make the codeptr point to a probe function which
// returns the 'this' pointer that was used.

// Define a generic class that uses virtual inheritance.
// It has a trival member function that returns the value of the 'this' pointer.
struct GenericVirtualClass : virtual public GenericClass
{
    typedef GenericVirtualClass *(GenericVirtualClass::*ProbePtrType)();
    GenericVirtualClass *self() { return this; }
};

// __virtual_inheritance classes go here
template <>
struct SimplifyMemFunc<SINGLE_MEMFUNCPTR_SIZE + 2*sizeof(int)>
{

    template <class X, class XFuncType, class GenericMemFuncType>
    inline static GenericClass *convert(X *pthis, XFuncType function_to_bind, 
                                        GenericMemFuncType &bound_func)
    {
        union
        {
            XFuncType func;
            GenericClass* (X::*ProbeFunc)();
            MicrosoftVirtualMFP s;
        } u;

        u.func = function_to_bind;
        bound_func = reinterpret_cast<GenericMemFuncType>(u.s.codeptr);

        union
        {
            GenericVirtualClass::ProbePtrType virtfunc;
            MicrosoftVirtualMFP s;
        } u2;

        // Check that the horrible_cast<>s will work
        typedef int ERROR_CantUsehorrible_cast[sizeof(function_to_bind) == sizeof(u.s)
            && sizeof(function_to_bind) == sizeof(u.ProbeFunc)
            && sizeof(u2.virtfunc) == sizeof(u2.s) ? 1 : -1];

        // Unfortunately, taking the address of a MF prevents it from being inlined, so 
        // this next line can't be completely optimised away by the compiler.
        u2.virtfunc = &GenericVirtualClass::self;
        u.s.codeptr = u2.s.codeptr;
        return (pthis->*u.ProbeFunc)();
    }
};

// Nasty hack for Microsoft and Intel (IA32 and Itanium)
// unknown_inheritance classes go here 
// This is probably the ugliest bit of code I've ever written. Look at the casts!
template <>
struct SimplifyMemFunc<SINGLE_MEMFUNCPTR_SIZE + 3 * sizeof(int) >
{
    template <class X, class XFuncType, class GenericMemFuncType>
    inline static GenericClass *convert(X *pthis, XFuncType function_to_bind, 
                                        GenericMemFuncType &bound_func)
    {
        // The member function pointer is 16 bytes long. We can't use a normal cast, but
        // we can use a union to do the conversion.
        union
        {
            XFuncType func;
            // In VC++ and ICL, an unknown_inheritance member pointer 
            // is internally defined as:
            struct
            {
                GenericMemFuncType m_funcaddress; // points to the actual member function
                int delta;        // #bytes to be added to the 'this' pointer
                int vtordisp;        // #bytes to add to 'this' to find the vtable
                int vtable_index; // or 0 if no virtual inheritance
            } s;
        } u;

        // Check that the horrible_cast will work
        typedef int ERROR_CantUsehorrible_cast[sizeof(XFuncType) == sizeof(u.s) ? 1 : -1];
        u.func = function_to_bind;
        bound_func = u.s.funcaddress;
        int virtual_delta = 0;
        if (u.s.vtable_index) { // Virtual inheritance is used
            // First, get to the vtable. 
            // It is 'vtordisp' bytes from the start of the class.
            const int * vtable = *reinterpret_cast<const int *const*>(
                reinterpret_cast<const char *>(pthis) + u.s.vtordisp);

            // 'vtable_index' tells us where in the table we should be looking.
            virtual_delta = u.s.vtordisp + *reinterpret_cast<const int *>( 
                reinterpret_cast<const char *>(vtable) + u.s.vtable_index);
        }
        // The int at 'virtual_delta' gives us the amount to add to 'this'.
        // Finally we can add the three components together. Phew!
        return reinterpret_cast<GenericClass *>(
            reinterpret_cast<char *>(pthis) + u.s.delta + virtual_delta);
    };
};

#endif // MS/Intel hacks

template<typename T>
class RemoteReferenceCounter
{
public:
    RemoteReferenceCounter() : ptr_(0) {}
    RemoteReferenceCounter(const RemoteReferenceCounter &c) { assign(c.ptr_); }
    ~RemoteReferenceCounter() { unreference(); }

    inline void assign(T *new_)
    {
        if (new_ == ptr_)
            return;

        unreference();
        ptr_ = new_;
        reference();
    }

    inline void operator =(const RemoteReferenceCounter &c) { assign(c.ptr_); }

private:
    inline void reference()
    {
        if (ptr_ != 0)
            ptr_->__intrusive_reference();
    }

    inline void unreference()
    {
        if (ptr_ == 0)
            return;

        assert(ptr_->__intrusive_refcount() > 0);
        ptr_->__intrusive_unreference();

        if (ptr_->__intrusive_refcount() == 0)
            delete ptr_;
    }

private:
    T *ptr_;
};

class AutoPtrBase
{
public:
    AutoPtrBase() : refs_(0) {}
    virtual ~AutoPtrBase() {}

    inline void __intrusive_reference() { ++refs_; }
    inline void __intrusive_unreference() { --refs_; }
    inline int __intrusive_refcount() const { return refs_; }

private:
    std::atomic<int> refs_;
    //volatile int refs_;
};

template<typename T>
class AutoPtr : public AutoPtrBase
{
public:
    AutoPtr(const T &t) : t_(t) {}

    inline T &object() { return t_; }

private:
    T t_;
};

template<typename T>
class AutoPtr<T *> : public AutoPtrBase
{
public:
    AutoPtr(T *t) : t_(t) {}
    ~AutoPtr() { delete t_; }

    inline T &object() { return *t_; }

private:
    T *t_;
};

}  // namespace Details

////////////////////////////////////////////////////////////////////////////////
//                        Fast Delegates, part 2:
//
//    Define the delegate storage, and cope with static functions
//
////////////////////////////////////////////////////////////////////////////////

// DelegateMemento -- an opaque structure which can hold an arbitary delegate.
// It knows nothing about the calling convention or number of arguments used by
// the function pointed to.
// It supplies comparison operators so that it can be stored in STL collections.
// It cannot be set to anything other than null, nor invoked directly: 
//   it must be converted to a specific delegate.

// Implementation:
//
// For compilers where data pointers are at least as big as code pointers, it is 
// possible to store the function pointer in the this pointer, using another 
// horrible_cast. In this case the DelegateMemento implementation is simple:
// +--pThis --+-- pMemFunc-+-- Meaning---------------------+
// |    0     |  0         | Empty                         |
// |  !=0     |  !=0*      | Static function or method call|
// +----------+------------+-------------------------------+
//  * For Metrowerks, this can be 0. (first virtual function in a 
//       single_inheritance class).
// Note that the Sun C++ and MSVC documentation explicitly state that they 
// support static_cast between void * and function pointers.

class DelegateMemento
{
protected: 
    // the data is protected, not private, because many
    // compilers have problems with template friends.
    typedef void (Details::GenericClass::*GenericMemFuncType)(); // arbitrary MFP.
    Details::GenericClass *m_pthis;
    GenericMemFuncType m_pFunction;
    Details::RemoteReferenceCounter<Details::AutoPtrBase> m_pImplicitObject;

public:
    DelegateMemento() :
        m_pthis(0),
        m_pFunction(0)
    {
    }

    inline void clear()
    {
        m_pthis = 0;
        m_pFunction = 0;
    }

public:
    inline bool isEqual(const DelegateMemento &x) const
    {
        return m_pthis == x.m_pthis && m_pFunction == x.m_pFunction;
    }

    // Provide a strict weak ordering for DelegateMementos.
    inline bool isLess(const DelegateMemento &right) const
    {
        if (m_pthis != right.m_pthis)
            return m_pthis < right.m_pthis;

        // There are no ordering operators for member function pointers, but we can fake one
        // by comparing each byte. The resulting ordering is arbitrary (and compiler-dependent),
        // but it permits storage in ordered STL containers.
        return memcmp(&m_pFunction, &right.m_pFunction, sizeof(m_pFunction)) < 0;
    }

    // BUGFIX (Mar 2005):
    // We can't just compare m_pFunction because on Metrowerks,
    // m_pFunction can be zero even if the delegate is not empty!
    inline bool operator !() const
    {
        return m_pthis==0 && m_pFunction==0;
    }

    inline bool empty() const
    {
        return m_pthis==0 && m_pFunction==0;
    }

public:
    DelegateMemento &operator =(const DelegateMemento &right)
    {
        setMementoFrom(right); 
        return *this;
    }

    inline bool operator <(const DelegateMemento &right) const
    {
        return isLess(right);
    }

    inline bool operator >(const DelegateMemento &right) const
    {
        return right.isLess(*this);
    }

    DelegateMemento (const DelegateMemento &right) :
        m_pthis(right.m_pthis),
        m_pFunction(right.m_pFunction),
        m_pImplicitObject(right.m_pImplicitObject)
    {
    }

protected:
    void setMementoFrom(const DelegateMemento &right)
    {
        m_pFunction = right.m_pFunction;
        m_pthis = right.m_pthis;
        m_pImplicitObject = right.m_pImplicitObject;
    }
};


//                        Closure<>
//
// A private wrapper class that adds function signatures to DelegateMemento.
// It's the class that does most of the actual work.
// The signatures are specified by:
// GenericMemFunc: must be a type of GenericClass member function pointer. 
// StaticFuncPtr:  must be a type of function pointer with the same signature 
//                 as GenericMemFunc.

// An outer class, FastDelegateN<>, handles the invoking and creates the
// necessary typedefs.
// This class does everything else.

namespace Details {

template <class GenericMemFunc, class StaticFuncPtr>
class Closure : public DelegateMemento
{
public:
    // These functions are for setting the delegate to a member function.

    // Here's the clever bit: we convert an arbitrary member function into a 
    // standard form. XMemberFun should be a member function of class X, but I can't 
    // enforce that here. It needs to be enforced by the wrapper class.
    template<class X, class XMemberFun>
    inline void bindMemberFn(X *pthis, XMemberFun function_to_bind)
    {
        m_pthis = SimplifyMemFunc<sizeof(function_to_bind)> \
                    ::convert(pthis, function_to_bind, m_pFunction);
    }

    // For const member functions, we only need a const class pointer.
    // Since we know that the member function is const, it's safe to 
    // remove the const qualifier from the 'this' pointer with a const_cast.
    // VC6 has problems if we just overload 'bindMemberFn', so we give it a different name.
    template<class X, class XMemberFun>
    inline void bindMemberFn(const X *pthis, XMemberFun function_to_bind)
    {
        m_pthis= SimplifyMemFunc<sizeof(function_to_bind)> \
                    ::convert(const_cast<X*>(pthis), function_to_bind, m_pFunction);
    }

    // These functions are required for invoking the stored function
    inline GenericClass *closureBase() const
    {
        return m_pthis;
    }

    inline GenericMemFunc closureMemFun() const
    {
        return reinterpret_cast<GenericMemFunc>(m_pFunction);
    }

    // There are a few ways of dealing with static function pointers.
    // There's a standard-compliant, but tricky method.
    // There's also a straightforward hack, that won't work on DOS compilers using the
    // medium memory model. It's so evil that I can't recommend it, but I've
    // implemented it anyway because it produces very nice asm code.

    //                Closure<> - Evil version
    //
    // For compilers where data pointers are at least as big as code pointers, it is 
    // possible to store the function pointer in the this pointer, using another 
    // horrible_cast. Invocation isn't any faster, but it saves 4 bytes, and
    // speeds up comparison and assignment. If C++ provided direct language support
    // for delegates, they would produce asm code that was almost identical to this.
    // Note that the Sun C++ and MSVC documentation explicitly state that they 
    // support static_cast between void * and function pointers.

    template<class DerivedClass>
    inline void copyFrom(DerivedClass *pParent, const DelegateMemento &right)
    {
        setMementoFrom(right);
    }

    // For static functions, the 'static_function_invoker' class in the parent 
    // will be called. The parent then needs to call staticFunction() to find out 
    // the actual function to invoke.
    // ******** EVIL, EVIL CODE! *******
    template<class DerivedClass, class ParentInvokerSig>
    inline void bindStaticFn(DerivedClass *pParent,
                              ParentInvokerSig static_function_invoker, 
                              StaticFuncPtr function_to_bind)
    {
        if (function_to_bind == 0)
        { // cope with assignment to 0
            m_pFunction = 0;
        } else { 
           // We'll be ignoring the 'this' pointer, but we need to make sure we pass
           // a valid value to bindMemberFn().
            bindMemberFn(pParent, static_function_invoker);
        }

        // WARNING! Evil hack. We store the function in the 'this' pointer!
        // Ensure that there's a compilation failure if function pointers 
        // and data pointers have different sizes.
        // If you see this error you're pretty skrewed
        typedef int ERROR_CantUseEvilMethod[sizeof(GenericClass *)==sizeof(function_to_bind) ? 1 : -1];
        m_pthis = horrible_cast<GenericClass *>(function_to_bind);
    }

    // ******** EVIL, EVIL CODE! *******
    // This function will be called with an invalid 'this' pointer!!
    // We're just returning the 'this' pointer, converted into
    // a function pointer!
    inline StaticFuncPtr staticFunction() const
    {
        // Ensure that there's a compilation failure if function pointers 
        // and data pointers have different sizes.
        typedef int ERROR_CantUseEvilMethod[sizeof(StaticFuncPtr)==sizeof(this) ? 1 : -1];
        return horrible_cast<StaticFuncPtr>(this);
    }

    inline void setImplicitObject(AutoPtrBase *deletable)
    {
        m_pImplicitObject.assign(deletable);
    }

    // Does the closure contain this static function?
    inline bool isEqualToStaticFuncPtr(StaticFuncPtr funcptr) const
    {
        if (funcptr==0) {
            return empty(); 
        } else {
            // For the Evil method, if it doesn't actually contain a static function, this will
            // return an arbitrary value that is not equal to any valid function pointer.
            return funcptr == reinterpret_cast<StaticFuncPtr>(staticFunction());
        }
    }
};

} /* namespace Details */

////////////////////////////////////////////////////////////////////////////////
//                        Fast Delegates, part 3:
//
//                Wrapper classes to ensure type safety
//
////////////////////////////////////////////////////////////////////////////////

// Once we have the member function conversion templates, it's easy to make the
// wrapper classes. So that they will work with as many compilers as possible, 
// the classes are of the form
//   Delegate<int, char *, double>
// They can cope with any combination of parameters.
// Note that we need to treat const member functions seperately.
// All this class does is to enforce type safety, and invoke the delegate with
// the correct list of parameters.

// Because of the weird rule about the class of derived member function pointers,
// you sometimes need to apply a downcast to the 'this' pointer.
// This is the reason for the use of "implicit_cast<X*>(pthis)" in the code below. 
// If CDerivedClass is derived from CBaseClass, but doesn't override SimpleVirtualFunction,
// without this trick you'd need to write:
//        MyDelegate(static_cast<CBaseClass *>(&d), &CDerivedClass::SimpleVirtualFunction);
// but with the trick you can write
//        MyDelegate(&d, &CDerivedClass::SimpleVirtualFunction);

// Implicit conversion to "bool" is achieved using the safe_bool idiom,
// using member data pointers (MDP). This allows "if (dg)..." syntax
// Because some compilers (eg codeplay) don't have a unique value for a zero
// MDP, an extra padding member is added to the SafeBool struct.
// Some compilers (eg VC6) won't implicitly convert from 0 to an MDP, so
// in that case the static function constructor is not made explicit; this
// allows "if (dg==0) ..." to compile.

template<typename ResultType=void, typename... Args>
class Delegate {
private:
    typedef ResultType (*StaticFunctionPtr)(Args...);
    typedef ResultType (Details::GenericClass::*GenericMemFn)(Args...);
    typedef Details::Closure<GenericMemFn, StaticFunctionPtr> ClosureType;

private:
    ClosureType closure_;

public:
    typedef Delegate type;

public: /* constructors */
    Delegate()
    {
        clear();
    }

    Delegate(const Delegate &x)
    {
        closure_.copyFrom(this, x.closure_);
    }

    explicit Delegate(ResultType (*function)(Args...))
    {
        bind(function);
    }

    template<typename Function, typename Pack>
    explicit Delegate(const Binder<ResultType, Function, Pack> &binder)
    {
        this->bind(binder);
    }

    template <class X, class Y>
    Delegate(Y *pthis, ResultType (X::*function_to_bind)(Args...))
    {
        closure_.bindMemberFn(Details::implicit_cast<X*>(pthis), function_to_bind);
    }

    template <class X, class Y>
    Delegate(const Y *pthis, ResultType (X::*function_to_bind)(Args...) const)
    {
        closure_.bindMemberFn(Details::implicit_cast<const X*>(pthis), function_to_bind);
    }

    template <class X, class Y>
    Delegate(const std::shared_ptr<Y> &pthis, ResultType (X::*function_to_bind)(Args...))
    {
        this->bind(pthis, function_to_bind);
    }

    template <class X, class Y>
    Delegate(const std::shared_ptr<Y> &pthis, ResultType (X::*function_to_bind)(Args...) const)
    {
        this->bind(pthis, function_to_bind);
    }

public:
    inline void clear()
    {
        closure_.clear();
    }

    inline bool empty() const
    {
        return !closure_;
    }

    inline const DelegateMemento &memento() const
    {
        return closure_;
    }

    inline void setMemento(const DelegateMemento &any)
    {
        closure_.copyFrom(this, any);
    }

public: /* binders */
    template <class X, class Y>
    inline void bind(Y *pthis, ResultType (X::*function_to_bind)(Args...))
    {
        closure_.bindMemberFn(Details::implicit_cast<X*>(pthis), function_to_bind);
    }

    template <class X, class Y>
    inline void bind(const Y *pthis, ResultType (X::*function_to_bind)(Args...) const)
    {
        closure_.bindMemberFn(Details::implicit_cast<const X *>(pthis), function_to_bind);
    }

    inline void bind(ResultType (*function_to_bind)(Args...))
    {
        closure_.bindStaticFn(this, &Delegate::invokeStaticFunction, function_to_bind);
    }

    template<typename Function, typename Pack>
    void bind(const Binder<ResultType, Function, Pack> &binder)
    {
        typedef Binder<ResultType, Function, Pack> BinderType;
        Details::AutoPtr<BinderType> *deletable = new Details::AutoPtr<BinderType>(binder);

        ResultType (BinderType::*function)(Args...) = &BinderType::invoke;
        closure_.setImplicitObject(deletable);
        closure_.bindMemberFn(&deletable->object(), function);
    }

    template <class X, class Y>
    inline void bind(const std::shared_ptr<Y> &pthis, ResultType (X::*function_to_bind)(Args...))
    {
        typedef typename std::shared_ptr<Y> PointerType;
        Details::AutoPtr<PointerType> *deletable = new Details::AutoPtr<PointerType>(pthis);

        closure_.setImplicitObject(deletable);
        closure_.bindMemberFn(Details::implicit_cast<X*>(pthis.get()), function_to_bind);
    }

    template <class X, class Y>
    inline void bind(const std::shared_ptr<Y> &pthis,
                     ResultType (X::*function_to_bind)(Args...) const)
    {
        typedef typename std::shared_ptr<Y> PointerType;
        Details::AutoPtr<PointerType> *deletable = new Details::AutoPtr<PointerType>(pthis);

        closure_.setImplicitObject(deletable);
        closure_.bindMemberFn(Details::implicit_cast<const X*>(pthis.get()), function_to_bind);
    }

public: /* operators */
    inline void operator =(const Delegate &x)
    {
        closure_.copyFrom(this, x.closure_);
    }

    inline void operator =(ResultType (*function_to_bind)(Args...)) const
    {
        bind(function_to_bind);
    }

    template<typename Function, typename Pack>
    inline void operator =(const Binder<ResultType, Function, Pack> &binder)
    {
        bind(binder);
    }

    inline bool operator ==(const Delegate &x) const
    {
        return closure_.isEqual(x.closure_);
    }

    inline bool operator ==(StaticFunctionPtr funcptr) const
    {
        return closure_.isEqualToStaticFuncPtr(funcptr);
    }

    inline bool operator !=(const Delegate &x) const
    {
        return !closure_.isEqual(x.closure_);
    }

    inline bool operator !=(StaticFunctionPtr funcptr) const
    {
        return !closure_.isEqualToStaticFuncPtr(funcptr);
    }

    inline bool operator !() const
    {
        return !closure_;
    }

    inline bool operator <(const Delegate &x) const
    {
        return closure_.isLess(x.closure_);
    }

    inline bool operator >(const Delegate &x) const
    {
        return x.closure_.isLess(closure_);
    }

    inline ResultType operator ()(Args... args) const
    {
        return (closure_.closureBase()->*(closure_.closureMemFun()))(args...);
    }

private: // Implicit conversion to "bool" using the safe_bool idiom
    typedef struct SafeBoolStruct
    {
        int a_data_pointer_to_this_is_0_on_buggy_compilers;
        StaticFunctionPtr m_nonzero;
    } UselessTypedef;

    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;

public:
    operator unspecified_bool_type() const
    {
        return !empty() ? &SafeBoolStruct::m_nonzero : 0;
    }

private:    // Invoker for static functions
    ResultType invokeStaticFunction(Args... args) const
    {
        return (*(closure_.staticFunction()))(args...);
    }
}; /* class Delegate */

/**
 * Delegate template specialization to allow boost-like function
 * declaration:
 *       Delegate<int (const char*, int)> delegate;
 */
template<typename R, typename... Args>
class Delegate<R (Args...)> : public Delegate<R, Args...>
{
public:
    typedef Delegate<R, Args...> BaseType;
    typedef Delegate SelfType;

    Delegate()
        : BaseType()
    {
    }

    template < class X, class Y >
    Delegate(Y * pthis, R (X::* function_to_bind)(Args...)) :
        BaseType(pthis, function_to_bind)
    {
    }

    template < class X, class Y >
    Delegate(const Y *pthis, R (X::* function_to_bind)(Args...) const) :
        BaseType(pthis, function_to_bind)
    {
    }

    Delegate(R (*function_to_bind)(Args...)) :
        BaseType(function_to_bind)
    {
    }

    template<typename Function, typename Pack>
    Delegate(const Binder<R, Function, Pack> &binder) :
        BaseType(binder)
    {
    }

    template <class X, class Y>
    Delegate(const std::shared_ptr<Y> &pthis, R (X::*function_to_bind)(Args...)) :
        BaseType(pthis, function_to_bind)
    {
    }

    template <class X, class Y>
    Delegate(const std::shared_ptr<Y> &pthis, R (X::*function_to_bind)(Args...) const) :
        BaseType(pthis, function_to_bind)
    {
    }

    void operator =(const BaseType &x)
    {
        *static_cast<BaseType*>(this) = x;
    }
};

/**
 * Convenience functions
 */

template<typename ResultType, typename... Args>
inline Delegate<ResultType (Args...)> make(ResultType (*f)(Args...))
{
    return Delegate<ResultType (Args...)>(f);
}

template <typename ResultType, typename X, typename Y, typename... Args>
inline Delegate<ResultType (Args...)> make(Y* x, ResultType (X::*func)(Args...))
{
    return Delegate<ResultType (Args...)>(x, func);
}

template <typename ResultType, typename X, typename Y, typename... Args>
inline Delegate<ResultType (Args...)> make(Y* x, ResultType (X::*func)(Args...) const)
{
    return Delegate<ResultType (Args...)>(x, func);
}

template <typename ResultType, typename X, typename Y, typename... Args>
inline Delegate<ResultType (Args...)> make(const std::shared_ptr<Y> &x,
                                           ResultType (X::*func)(Args...))
{
    return Delegate<ResultType (Args...)>(x, func);
}

template <typename ResultType, typename X, typename Y, typename... Args>
inline Delegate<ResultType (Args...)> make(const std::shared_ptr<Y> &x,
                                           ResultType (X::*func)(Args...) const)
{
    return Delegate<ResultType (Args...)>(x, func);
}

} /* namespace Delegate */
} /* namespace Hypergrace */

#endif /* DELEGATE_DELEGATE_HH_ */
